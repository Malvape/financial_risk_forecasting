acf(x)
x <- numeric()
x[1] <- runif(1)
x[1] <- rnorm(1)
x <- numeric()
x[1] <- rnorm(1)
for (i in 2:1024){
x[i] <- 0.8*x[i-1] + rnorm(1)
}
plot(x)
acf(x)
x <- numeric()
x[1] <- rnorm(1)
for (i in 2:1024){
x[i] <- 0.9*x[i-1] + rnorm(1)
}
acf(x)
x <- numeric()
x[1] <- rnorm(1)
for (i in 2:1024){
x[i] <- -0.9*x[i-1] + rnorm(1)
}
acf(x)
x <- numeric()
x[1:9] <- rnorm(9)
x <- numeric()
x[1] <- runif(1)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(1)), sd=1)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(0.9)), sd=1)
plot(x)
acf(x)
x = arima.sim(n=1024, list(ar=c(-0.8), ma=c(0.9)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(-1.9)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(0.9)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.4), ma=c(0.9)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(0.9)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(2)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(1)), sd=2)
acf(x)
x = arima.sim(n=300, list(ar=c(0.5), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(1.5), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=300, list(ar=c(0.99), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.95), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.9), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(1)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(-1)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(1,2)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(1,2,3)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(1,1)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.8), ma=c(1,2)), sd=1)
acf(x)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(1,2)), sd=1)
acf(x)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1,2)), sd=1)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1,2)), sd=2)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1,2)), sd=5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1,2)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(4,2)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1,1)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1)), sd=0.5)
acf(x, 50)
?arima.sim
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6), ma=c(1, 2)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6, 0.8), ma=c(1, 2)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.6, 0.25), ma=c(1, 2)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.3, 0.25), ma=c(1, 2)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(1, 2)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(1)), sd=0.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(1)), sd=1)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(1)), sd=1.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(0.00001)), sd=1.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(0)), sd=1.5)
acf(x, 50)
x = arima.sim(n=1024, list(ar=c(0.5), ma=c(0.5)), sd=1.5)
acf(x, 50)
x <- runif(1000)
hist(x)
x <- runif(10000)
hist(x)
x <- runif(100000)
hist(x)
x <- runif(1000000)
hist(x)
x <- runif(10000000)
hist(x)
x <- rnorm(10000000)
hist(x)
library(forecast)
library(moments)
library(timeSeries)
library(tseries)
jarque.bera.test(x)
x[1] <- runif(1)
x <- numeric()
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(2/pi * x[i-1]) + rnorm(1)
}
plot(x)
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(2/pi + x[i-1]) + rnorm(1)
}
plot(x)
delayplot<-function(x,d)
#
# delayplot(x,d);
# x is a univariate array
# d is the delay time
{
plot(x[1:(length(x)-d)],x[(1+d):length(x)], xlab = "X_t", ylab = paste0("X_t+",d),
main = paste("Delayplot of Xt. Delays =",d))
}
delayplot(x,1)
delayplot(x,2)
x <- numeric()
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(i) + rnorm(1)
}
plot(x)
delayplot(x,1)
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(i)
}
plot(x)
delayplot(x,1)
for (i in 2:1024) {
x[i] <- sin(2/i)
}
plot(x)
delayplot(x,1)
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(i)
}
plot(x)
delayplot(x,1)
x <- numeric()
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(0.1*i)
}
plot(x)
delayplot(x,1)
x <- numeric()
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(7**i)
}
plot(x)
x <- numeric()
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(7*i)
}
plot(x)
delayplot(x,1)
plot(x)
x <- numeric()
x[1] <- runif(1)
for (i in 2:1024) {
x[i] <- sin(i)
}
plot(x)
delayplot(x,1)
plot(x)
plot(x, TYPE="L")
plot(x, TYPE="l")
plot(x, type="l")
hist(x)
x <- numeric()
y <- numeric()
x[1] <- runif(1)
y[1] <- runif(1)
install.packages("IRkernel")
IRkernel::isntallspec()
IRkernel::installspec()
IRkernel::installspec(name = 'ir33', displayname = 'R 3.3')
library(music)
# Create system of notes
notes <- c("C", "C#", "D", "Eb", "E", "F", "F#", "G", "G#", "A", "Bb", "B")
allnotes <- character()
for (i in 3:8) {
for (j in 1:length(notes)) {
allnotes = c(allnotes, paste0(notes[j],i))
}
}
# Adding Collatz numbers
collatz_stop <- function(N) {
# Returns steps needed for the series to reach 1
steps = 0
while (N != 1) {
if (N %% 2 == 0) {
N = N/2
} else {
N = 3 * N + 1
}
steps = steps + 1
}
return(steps)
}
collatz <- numeric()
for (i in 2:200) {
collatz[i-1] = collatz_stop(i)
}
length(unique(collatz))
keys <- sort(unique(collatz))
# Transform collatz into notes
collatz_notes <- numeric()
for (i in 1:length(collatz)) {
collatz_notes[i] <- allnotes[match(collatz[i], keys)]
}
durations <- function(x) {
tmp_seq <- sequence(rle(as.character(x))$lengths)
tmp_new <- numeric()
for (i in 1:length(tmp_seq)) {
if (tmp_seq[i+1] != 1  & i < length(tmp_seq)) {
tmp_new[i] <- NA
} else {
tmp_new[i] <- tmp_seq[i]
}
}
music <- matrix(NA, nrow = length(x), ncol = 2)
music[,1] <- x
music[,2] <- tmp_new
music <- music[which(!is.na(music[,2])),]
return(music)
}
# Get the matrix for Collatz
collatz_music <- durations(collatz_notes)
collatz_music
collatz <- numeric()
for (i in 2:200) {
collatz[i-1] = collatz_stop(i)
}
collatz
collatz[collatz > 50]
plot(collatz[collatz > 50])
collatz <- collatz[collatz > 50]
length(unique(collatz))
keys <- sort(unique(collatz))
# Transform collatz into notes
collatz_notes <- numeric()
for (i in 1:length(collatz)) {
collatz_notes[i] <- allnotes[match(collatz[i], keys)]
}
durations <- function(x) {
tmp_seq <- sequence(rle(as.character(x))$lengths)
tmp_new <- numeric()
for (i in 1:length(tmp_seq)) {
if (tmp_seq[i+1] != 1  & i < length(tmp_seq)) {
tmp_new[i] <- NA
} else {
tmp_new[i] <- tmp_seq[i]
}
}
music <- matrix(NA, nrow = length(x), ncol = 2)
music[,1] <- x
music[,2] <- tmp_new
music <- music[which(!is.na(music[,2])),]
return(music)
}
# Get the matrix for Collatz
collatz_music <- durations(collatz_notes)
collatz_music
# Play it!
bpm <- 150
for (i in 1:dim(collatz_music)[1]) {
playNote(collatz_music[i,1], duration = as.integer(collatz_music[i,2]), BPM = bpm)
Sys.sleep(60*as.integer(collatz_music[i,2])/bpm)
}
collatz <- collatz[collatz > 80]
length(unique(collatz))
keys <- sort(unique(collatz))
# Transform collatz into notes
collatz_notes <- numeric()
for (i in 1:length(collatz)) {
collatz_notes[i] <- allnotes[match(collatz[i], keys)]
}
durations <- function(x) {
tmp_seq <- sequence(rle(as.character(x))$lengths)
tmp_new <- numeric()
for (i in 1:length(tmp_seq)) {
if (tmp_seq[i+1] != 1  & i < length(tmp_seq)) {
tmp_new[i] <- NA
} else {
tmp_new[i] <- tmp_seq[i]
}
}
music <- matrix(NA, nrow = length(x), ncol = 2)
music[,1] <- x
music[,2] <- tmp_new
music <- music[which(!is.na(music[,2])),]
return(music)
}
# Get the matrix for Collatz
collatz_music <- durations(collatz_notes)
collatz_music
# Play it!
bpm <- 150
for (i in 1:dim(collatz_music)[1]) {
playNote(collatz_music[i,1], duration = as.integer(collatz_music[i,2]), BPM = bpm)
Sys.sleep(60*as.integer(collatz_music[i,2])/bpm)
}
# Get the matrix for Collatz
collatz_notes
# Get the matrix for Collatz
collatz_music <- collatz_notes
# Play it!
bpm <- 150
for (i in 1:dim(collatz_music)[1]) {
playNote(collatz_music[i,1], duration = as.integer(collatz_music[i,2]), BPM = bpm)
Sys.sleep(60*as.integer(collatz_music[i,2])/bpm)
}
playProgression(collatz_music)
remove.packages("Cairo")
library(car)
install.packages("car")
install.packages("car")
install.packages('car','/Users/alvaroaguirre/opt/anaconda3/lib/R/library')
install.packages('rugarch','/Users/alvaroaguirre/opt/anaconda3/lib/R/library')
install.packages('nloptr','/Users/alvaroaguirre/opt/anaconda3/lib/R/library')
library(car)
install.packages('carData','/Users/alvaroaguirre/opt/anaconda3/lib/R/library')
install.packages("carData", "/Users/alvaroaguirre/opt/anaconda3/lib/R/library")
install.packages("car", "/Users/alvaroaguirre/opt/anaconda3/lib/R/library")
find.package("factoextra")
find.package("car")
.Library
x <- data.frame("Stock" = c("A", "B"), "Price" = c(42,68))
x
require(devtools)
install_version("repr", version = "0.19.2", repos = "http://cran.us.r-project.org")
install.packages("devtools")
require(devtools)
install_version("repr", version = "0.19.2", repos = "http://cran.us.r-project.org")
library(rugarch)
rugarch::plot()
?rugarch::plot
library(rugarch)
ugarchfit
showMethods("ugarchfit")
?ugarchfit
# Load the data
load("Y.RData")
# Extract the returns for GE
y <- Y$GE
# View them
head(y)
setwd("~/SRC/Dropbox/Alvaro/R-material/Materials-2020/Seminar6")
# Load the data
load("Y.RData")
# Extract the returns for GE
y <- Y$GE
# View them
head(y)
# Plot the returns
plot(y, type = "l", main = "Returns for GE")
setwd("~/SRC/Dropbox/Alvaro/R-material/Materials-2020/Seminar7")
library(lubridate)
library(rugarch)
# Loading the data
load("Y.RData")
y <- Y$MSFT
dates <- Y$date
# Plot the returns
plot(dates, y, main = "Microsoft returns", type = "l", lwd = 2, las = 1,
xlab = "Date", ylab = "Returns")
# Specifying the parameters for VaR
p <- 0.05
portfolio_value <- 1000000
# Specifying the parameters for EWMA
lambda <- 0.94
n <- length(y)
BurnTime <- 30
# Vector to store estimated conditional volatility
EWMA_Variance <- rep(NA, length = n)
# First value is the sample variance
EWMA_Variance[1] <- var(y)
# See the vector
head(EWMA_Variance)
# Run the EWMA model using a for loop
for (i in 2:n) {
EWMA_Variance[i] <- lambda * EWMA_Variance[i-1] + (1-lambda) * y[i-1]^2
}
# We should then eliminate the first 30 observations given it is the minimum estimation window
EWMA_Variance[1:BurnTime] <- NA
# Plot estimation for conditional volatility
EWMA_cond_volatility <- sqrt(EWMA_Variance)
plot(dates, EWMA_cond_volatility, type = "l", main = "EWMA Conditional Volatility",
las = 1, col = "red", xlab = "Date", ylab = "EWMA Cond. Volatility")
# Implementing the VaR forecast
EWMA_VaR <- -qnorm(p) * EWMA_cond_volatility * portfolio_value
# This option prevents scientific notation on the axes
options(scipen=1)
# Plotting it
plot(dates, EWMA_VaR, type = "l", main = "EWMA VaR",
las = 1, col = "red", xlab = "Date", ylab = "USD")
DoHS <- function(y, probability = 0.05, portfolio_value = 1, WE = 1000){
# HS function that takes as argument:
# y: A vector of returns, ordered by date
# probability: The probability to be used for VaR - Default 5%
# portfolio_value: The portfolio value - Default 1
# WE: Estimation window for the forecast - Default 1000 days
# Print message
cat("Doing Historical simulation VaR forecast", "\n",
"Estimation window:", WE, "\n",
"Number of observations:", length(y), "\n",
"VaR probability:", probability, "\n",
"Portfolio value:", portfolio_value)
# Number of observations
n <- length(y)
# Initialize empty VaR vector
VaR <- rep(NA, n)
# Do a loop for the forecast
for (i in 1:(n-WE)){
# Sort the returns for the estimation window
ys <- sort(y[i:(i+WE)])
# Get the quantile
quant <- ceiling(probability * length(ys))
# Allocate the VaR forecast in the vector
VaR[i+WE] <- -ys[quant]*portfolio_value
}
# Return the VaR vector
return(VaR)
}
# Historical Simulation with an estimation window of 300 days
HS300 <- DoHS(y, probability = p, portfolio_value = portfolio_value, WE = 300)
DoGARCH <- function(y, spec, probability = 0.05, portfolio_value = 1, WE = 1000){
# GARCH function that takes as argument:
# y: A vector of returns, ordered by date
# spec: The ugarchspec object with the GARCH specification
# probability: The probability to be used for VaR - Default 5%
# portfolio_value: The portfolio value - Default 1
# WE: Estimation window for the forecast - Default 1000 days
# Print message
cat("Doing GARCH VaR forecast", "\n",
"Estimation window:", WE, "\n",
"Number of observations:", length(y), "\n",
"VaR probability:", probability, "\n",
"Portfolio value:", portfolio_value)
# Number of observations
n <- length(y)
# Initialize empty VaR vector
VaR <- rep(NA, n)
# Do a loop for the forecast
for (i in 1:(n-WE)){
# Subset the dataset to the estimation window
window <- y[i:(i+WE-1)]
# Fit the GARCH
res <- ugarchfit(spec = spec, data = window, solver = "hybrid")
# Save coefficients
omega <- coef(res)['omega']
alpha <- coef(res)['alpha1']
beta <- coef(res)['beta1']
# Estimate sigma2 using the last observation of window
sigma2 <- omega + alpha*tail(window,1)^2 + beta*tail(res@fit$var,1)
# Allocate the VaR forecast in the vector
VaR[i+WE] <- -sqrt(sigma2) * qnorm(probability) * portfolio_value
}
# Return the VaR vector
return(VaR)
}
# Create specification
spec <- ugarchspec(
variance.model = list(garchOrder= c(1,1)),
mean.model= list(armaOrder = c(0,0), include.mean=FALSE)
)
# GARCH VaR for 300 days
GARCH300 <- DoGARCH(y, spec = spec, probability = p, portfolio_value = 1000000, WE = 300)
